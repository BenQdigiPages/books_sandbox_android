///
/// Data format for color
///
/// @r: 0 ... 255 - red
/// @g: 0 ... 255 - green
/// @b: 0 ... 255 - blue
///
[r, g, b]

///
/// Data format for bookmark
///
/// @uuid: string - uuid for bookmark, uuid is generated by App
/// @title: string - chapter title of this bookmark
/// @page: int - page number of this bookmark
/// @cfi: string - epub cfi
/// @color: string - either "red", "yellow" or "blue"
///
{
    "uuid": uuid,
    "title": title,
    "page": page,
    "cfi": cfi,
    "color": color,
}

///
/// Data format for highlight
///
/// @uuid: string - uuid for highlight, uuid is generated by App
/// @title: string - chapter title of this highlight
/// @page: int - page number of this highlight
/// @cfi: string - epub cfi
/// @color: string - either "red", "yellow" or "blue"
/// @text: string - the preview text in the highlight range
///
{
    "uuid": uuid,
    "title": title,
    "page": page,
    "cfi": cfi,
    "color": color,
    "text": text,
}

///
/// Data format for entry of table of content
///
/// @title: string - title of entry, may contain <span> level html tag
/// @link: string - link to this entry (opaque, defined by Viewer)
/// @level: int - level of this entry, start from 0
///
{
    "title": title,
    "link": link,
    "level": level,
}

///
/// Data format for search result
///
/// @text: string - preview text of search result, including keyword
/// @html: string - html version of preview, optional
/// @cfi: string - epub cfi
///
{
    "text": text,
    "html": html,
    "cfi": cfi,
}

-----------------------------------------------------------------------------

Viewer provides the following javascript functions:

///
/// Load ebook from server url
/// App will act as transparent proxy, and provides offline content
/// if available
///
/// App may request legacy mode, which can not handle partial GET.
/// If legacy mode is activated, Viewer should put "Range" header in
/// query parameter "_Range_", and issue normal HTTP GET request.
///
/// @url: string - base url of ebook
/// @legacy: bool - true if legacy mode is needed
///
Viewer.loadBook(url, legacy)

///
/// Set the text appearance
///
/// @text_size: int - in pt unit
/// @[r, g, b] - text color
///
Viewer.setTextAppearance(text_size, [r, g, b])

///
/// Set page background color
///
/// @[r, g, b] - page background color
///
Viewer.setBackgroundColor([r, g, b])

///
/// Set page background image
///
/// @image_url - page background image url
///
Viewer.setBackgroundImage(image_url)

///
/// Get an array of available page layout modes for this book
///
/// @mode: string - either "single", "side_by_side" or "continuous"
///
Viewer.getAvailableLayoutModes() -> [mode, ...]

///
/// Get current page layout mode
///
/// @mode: string - either "single", "side_by_side" or "continuous"
///
Viewer.getLayoutMode() -> mode

///
/// Set page layout mode
///
/// @mode: string - either "single", "side_by_side" or "continuous"
///
Viewer.setLayoutMode(mode)

///
/// Get current position in the ebook
///
/// @title: string - chapter title of this position
/// @cfi: string - epub cfi
/// @current_page: int - page number of current page
/// @total_pages: int - total number of pages
///
Viewer.getCurrentPosition() -> [title, cfi, current_page, total_pages]

///
/// Goto the given link in this ebook, the link is from table of content
/// that Viewer sent back to App with App.onChangeTOC
///
/// @link: string - target link (opaque, defined by Viewer)
///
Viewer.gotoLink(link)

///
/// Goto the given position in this ebook
///
/// @cfi: string - epub cfi
///
Viewer.gotoPosition(cfi)

///
/// Toggle the bookmark in the current page.
///
/// If a valid tag is specified, viewer should call App.onAddBookmark
/// or App.onUpdateBookmark in response.
///
/// If null is specified, viewer should call App.onRemoveBookmark in response,
/// or do nothing if there is currently no bookmark
///
/// @tag: string or null
///     color - the bookmark color type, either "red", "yellow" or "blue"
///     null - to remove current bookmark
/// @page_offset: either 0 or 1
///     for single page mode, page_offset is always 0
///     for side by side mode, 0 is for left page, 1 is for right page
///
Viewer.toggleBookmark(color, page_offset)

///
/// Search text and mark the found text, the search is case-insensitive
/// viewer should call App.onSearchFound in response
///
/// @keyword: string or null - the keyword to be found,
///     or null to cancel search mode
///
Viewer.searchText(keyword)

-----------------------------------------------------------------------------

Application export the following functions to javascript:

///
/// App provides color to bookmark icon url mapping
/// @color - either "red", "yellow" or "blue"
///
App.bookmarkIconUrl[color]

///
/// Notify App current view frame is changed
/// This is needed for PDF annotation
/// Content offset is the relative position (after scaling) to the top-left corner.
/// Content offset (x: -10, y: -20) will make top edge 20 pixels off-screen,
/// left edge 10 pixels off-screen
///
/// @offset_x: number - content offset x
/// @offset_y: number - content offset y
/// @scale: number - scale of content view, 1.0 is original size
///
App.onChangeView(offset_x, offset_y, scale)

///
/// Notify App current title is changed
///
/// @title: string - title to be shown on toolbar
///
App.onChangeTitle(title)

///
/// Notify App current table of content is changed
///
/// @[toc_entry, ...]: array - an array to the TOC entry
///
App.onChangeTOC([toc_entry, ...])

///
/// Notify App current page is changed to different page
///
/// @title: string - chapter title of this page
/// @cfi: string - epub cfi
/// @current_page: int - page number of current page
/// @total_pages: int - total number of pages
///
App.onChangePage(title, cfi, current_page, total_pages)

///
/// Notify App user action for tracking
///
/// @action: string - tracking "action" as defined in doc
/// @cfi: string - tracking "cfi" as defined in doc, may be empty for some action
///
App.onTrackAction(action, cfi)

///
/// Notify App to show or hide toolbar
///
/// @visible: bool - set visibility of tool bar
///
App.onToggleToolbar(visible)

///
/// Request App to load highlights for this book, App will call callback in response
/// The callback will receive an array of object to represent highlights
///
///     function callback([highlight, ...])
///
/// @callback: string - name of callback function (can be object member function)
///     do not pass function itself, only name (as string) is needed;
///     and the function must be accessable from global space
///
App.onRequestHighlights(callback)

///
/// Notify App the given highlight need to be added, App will call callback in response
/// The callback will receive the UUID of new highlight just created
///
///     function callback(uuid)
///
/// @highlight - an object to represent highlight, uuid is absent in this case
/// @callback: string - name of callback function (can be object member function);
///     do not pass function itself, only name (as string) is needed;
///     and the function must be accessable from global space
///
App.onAddHighlight(highlight, callback)

///
/// Notify App the given highlight need to be updated
///
/// @highlight - an object to represent highlight
///
App.onUpdateHighlight(highlight)

///
/// Notify App the given highlight need to be deleted
///
/// @uuid - uuid of the highlight
///
App.onRemoveHighlight(uuid)

///
/// Notify App the given highlight need to be shared, App will popup sharing dialog
///
/// @uuid - uuid of the highlight
///
App.onShareHighlight(uuid)

///
/// Notify App the given highlight need to be annotated, App will popup edit window
///
/// @uuid - uuid of the highlight
///
App.onAnnotateHighlight(uuid)

///
/// Request App to load bookmark for this book, App will call callback in response
/// The callback will receive an array of object to represent bookmarks
///
///     function callback([bookmark, ...])
///
/// @callback: string - name of callback function (can be object member function);
///     do not pass function itself, only name (as string) is needed;
///     and the function must be accessable from global space
///
App.onRequestBookmarks(callback)

///
/// Notify App the given bookmark need to be added, App will call callback in response
/// The callback will receive the UUID of new bookmark just created
///
///     function callback(uuid)
///
/// @bookmark - an object to represent bookmark, uuid is absent in this case
/// @callback: string - name of callback function (can be object member function);
///     do not pass function itself, only name (as string) is needed;
///     and the function must be accessable from global space
///
App.onAddBookmark(bookmark, callback)

///
/// Notify App the given bookmark need to be updated
///
/// @bookmark - an json object to represent bookmark
///
App.onUpdateBookmark(bookmark)

///
/// Notify App the given bookmark need to be deleted
///
/// @uuid - uuid of the bookmark
///
App.onRemoveBookmark(uuid)

///
/// Notify App the search result is found
/// View can call this multiple times until App call Viewer.searchText(null)
///
/// @keyword - the search keyword
/// @result - an json object to represent search result
///
App.onSearchResult(keyword, [result, ...])
